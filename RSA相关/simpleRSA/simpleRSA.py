import gmpy2
from Crypto.Util.number import long_to_bytes
from Crypto.PublicKey import RSA

# n = p * q
# n = 1605247600724752598798254639224215706171506359654961357324428027985787942008103766562745464838961569081446916113769517713344420113584254259000172572811154232107339480903672251992191997458469905064423618888336088652352540882576826988355783159237971043770132628344798937353150930071309347972804118952814447576207066147031238749098842662046825743988208813903138796789940911515825517078554074496474819128789835309636804325132602557092847746454786387067599510769382078521691609970320528531270474091713477040343897269903489441410062592732302402854035415438078656688806905350495825334584533345448091335565792091890185673190424063
# 密文c
# c = 751639057610677013264061431434189083017589908118307247217007533938435229431015858783222167911772848893015518607229280589985711010766459396989232072512314594917029375221335361209036112742388866873824163350886610514973038316512032459352053158417705406031466332440378871927174731975794579894912999936641163063898365134788537389162378185448090279397717831977803284480743612393591614284972981435749362255654561121758163485884075260156288337176713756471879489767416836868661153693157792733142765671887792303181376620864506386820826866340907593080654521498766421056474652652337037121881207188033108746890998208582406826010121861
# 公钥e
# e = 65537

def gcd(a, b):
    # 求解最大公因数 
    if b == 0:
        return a
    else:
        return gcd(b, a % b)

# assert len(FLAG) == 42
# n1 = P * Q1                                               --> 此处n1 n2的P相同, Q不同
# n2 = P * Q2
# c1 = pow(bytes_to_long(FLAG), E1, n1)
# c2 = pow(bytes_to_long(FLAG), E2, n2)
n1 = 21655617838358037895534605162358784326495251462447218485102155997156394132443891540203860915433559917314267455046844360743623050975083617915806922096697304603878134295964650430393375225792781804726292460923708890722827436552209016368047420993613497196059326374616217655625810171080545267058266278112647715784756433895809757917070401895613168910166812566545593405362953487807840539425383123369842741821260523005208479361484891762714749721683834754601596796707669718084343845276793153649005628590896279281956588607062999398889314240295073524688108299345609307659091936270255367762936542565961639163236594456862919813549
n2 = 24623016338698579967431781680200075706241014384066250660360949684385831604822817314457973559632215801205780786144608311361063622813017396858888436529116737754653067203843306015767091585697803364656624926853551997229897087731298797904208292585562517602132663331748784390752958757661484560335406769204491939879324079089140420467301773366050084810282369044622442784113688062220370531522036512803461607049619641336524486507388232280683726065679295742456158606213294533956580462863488082028563360006966912264908424680686577344549034033470952036766850596897062924137344079889301948258438680545785139118107899367307031396309
P = gcd(n1, n2)
# P = 139221606892711163311861502165720779685040991146236819771077311473266519931947605782571900027963055886773086091452724527664738159398782494677824268515616754695749805253260616352348311702497776259344985568675527862394653437170150947836869132073518219409311180128931469597871185033476336585646820347139844842399
Q1 = n1 // P
Q2 = n2 // P



# p = getPrime(1024)
# q = next_prime(getPrime(16) * p + 38219)
# n = p * q
# c = pow(E1, 65537, n)                                     --> e = 65537, 明文m = E1
# E1 = gmpy2.powmod(c, d, n)




# assert E2.bit_length() == 69                              --> E2为69位
# ns = [getPrime(1024) * getPrime(1024) for _ in range(3)]  --> 获得3个n
# cs = [pow(E2, 89, n) for n in ns]                         --> e = 89, 获得3个密文c, E2为相同明文
E2 = 561236991551738266288
